<!DOCTYPE html>
<html lang="en">
<head>
    <!-- GoatCounter Analytics -->
    <script data-goatcounter="https://pcdemo.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>

    <meta charset="UTF-8">
    <meta name="robots" content="noindex, nofollow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taxonomies</title>
    <!-- Bootstrap CSS -->
<!-- Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<link href='https://use.fontawesome.com/releases/v5.6.1/css/all.css' rel="stylesheet">
<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- Bootstrap Icons -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.5.0/font/bootstrap-icons.css" rel="stylesheet">

<!-- jQuery CDN -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="./lib/bundle.js"></script>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" integrity="sha512-r22gChDnGvBylk90+2e/ycr3RVrDi8DIOkIGNhJlKfuyQM4tIRAI062MaV8sfjQKYVGjOBaZBOA87z+IhZE9DA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js"></script>
<script src="metadata.js"></script>
<script src="taxonomy.js"></script>
<script src="schemas.js"></script>
<link rel="stylesheet" href="import.css"/>
<!-- Connection Status Styles -->
<link rel="stylesheet" href="connection-status.css"/>

    <style>
     .form-input {
    width: auto;
    max-width: 300px;  /* Adjust the max-width to your desired size */
    margin: 0 auto;    /* Centers the input within its container */
}




    </style>
    

    <script>
        const { BoxClient, BoxDeveloperTokenAuth } =window['box-typescript-sdk-gen'];
        var client;
        var accessToken=sessionStorage.getItem("token");//'1!ovMAnpXZqiVIIHfEmAgKsaxAYGqT54wQLOCjDudE9OOlot9_RhQXRncyKgiw1-eymQjVGe4YONcsCZZ2JUcmc9GyHLCYGfEOwMg8lP2pghjtJg_BpbgXerqucuVnYQJkknxTeJvNfSfEiu8GhShkgxupj02JPjdxoy4Eyj6AfavchgCS0x1huzmUPv4Q-Wi6zjqTjwATWXwWbVutAJ4_GSEFydHf751iqRWxA-bJaVuqB7FtVArcie7jDUuTcu3OsDZfRYzZZIvg5OWmOLKS-jbO0Gbj3MmXSDv__elJVQANjVDRWE6N5nzBM-ii1fQZtqiERKioKN3dxGI-M4NOZfEIh6MsHHtcbL9aJKvXpa05Ln76ro5IjzC01YfuRI0Ap1vf7c57b1G1gXprd4NvODd2mQqj_hUy43kk-v2Z2TSijyTuhj7yeF2BAgS5MyXBCNZctNVsPIGnBpR6bD1_lwsLZNkUz4ND-3b0iksLw7aZJhcT3FQW0vsrhu8QA3RJ-mQRl42pJ65dh4Ri5A9dsvGxr1uq2lCCwiemwR6zILZoSVoOp6q4d81EEMyaXXPtZHlD0eOeVO1krm6RnlaG9y6ZMXvS4nzJBv8tHiD3VxRap9ye_YeD6xXR_5rZHHiXpxwpBUM4bsDSUEsiyNYCuNMrcwNnpf0eYll6KOlnG908Xt6SYuyzqNgflrNWWhG_wT3-sVdqy-TVftYeLHYkCKPzyN2GYPb47awVjyBLUQZhWDrTItJRmwjc30b3-NfYfIhFiwnnKa-N6VthbRsCBB1NcjhwCpcKF9AWWl_iM4dqyNZ0myghxR0ZqNXnfWDNOpKmSFZtQTEpz-NVupTteW-EmAgOmn0vyG1y';        var selectedFolder=null;
        var eid;
        var editor;
        var namespace;
        let originalEntries = []; // populate this when loading
        let taxonomyLevels = [];  // also store this when loading
        let taxonomyId;
        var nodesToCreate=0;
        var nodesCreated=0;
        var metadataTaxonomies;

        $(document).ready(async function() {
          // Debug: Check what functions are available

           $("#import").click(function() {
                $("#fileInput").show();                            
            });
            $('#fileInput').on('change', function (e) {
              console.log('üîÑ File input change event triggered');
              const file = e.target.files[0];
              console.log('üìÅ File selected:', file.name, 'Size:', file.size);
              
              const reader = new FileReader();
            
              reader.onload = function (e) {
                console.log('üìñ File read completed');
                const data = new Uint8Array(e.target.result);
                console.log('üìä Data length:', data.length);
                
                const workbook = XLSX.read(data, { type: 'array' });
                console.log('üìã Workbook sheets:', workbook.SheetNames);
                
                const sheetName = workbook.SheetNames[0];
                let sheet = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { defval: null });
                console.log('üìÑ Raw sheet data:', sheet);
                console.log('üìÑ Sheet length:', sheet.length);
            
                if (!sheet.length) {
                  console.error('‚ùå No data found in Excel file');
                  return;
                }
            
                const columns = Object.keys(sheet[0]);
                console.log('üè∑Ô∏è Columns found:', columns);
                console.log('üè∑Ô∏è Column count:', columns.length);
                
                taxonomyLevels = columns.map(name => ({ displayName: name, description: name }));
                console.log('üè∑Ô∏è Taxonomy levels created:', taxonomyLevels);
            
                // Fill down empty cells
                console.log('üßπ Starting to fill down empty cells...');
                for (let i = 1; i < sheet.length; i++) {
                  for (let col of columns) {
                    if (!sheet[i][col]) {
                      sheet[i][col] = sheet[i - 1][col];
                    }
                  }
                }
                
            
                // Remove incomplete rows
                const originalLength = sheet.length;
                sheet = sheet.filter(row => row[columns[columns.length - 1]]);
                if (typeof buildTree !== 'function') {
                  console.error('‚ùå buildTree function is not available!');
                  return;
                }
                
                const nestedTree = buildTree(sheet, columns);
                if (Array.isArray(nestedTree) && nestedTree.length > 0) {
                  console.log('üå≥ First tree node:', nestedTree[0]);
                  console.log('üå≥ First tree node keys:', Object.keys(nestedTree[0]));
                }
                
                // Calculate maxLevel from the actual data, not from empty originalEntries
                const maxLevel = columns.length;
                console.log('üìè Max level calculated:', maxLevel);
                console.log('üìè Columns length:', columns.length);
                
                console.log('üåø Calling convertNestedToJsTree function...');
                const jsTreeNodes = convertNestedToJsTree(nestedTree, maxLevel);
                console.log('üåø convertNestedToJsTree result:', jsTreeNodes);
                console.log('üåø First few nodes:', jsTreeNodes.slice(0, 3));
                console.log('üåø Node structure check:', jsTreeNodes[0] ? Object.keys(jsTreeNodes[0]) : 'No nodes');
            
                const name = file.name.replace(/\.[^/.]+$/, "");
                console.log('üìù Processed name:', name);
                
                originalEntries = [];
                taxonomyId = null; 
                $('#taxonomyKey').val(name.toLowerCase().replace(/\s+/g, '_'));
                $('#taxonomyDisplayName').val(name);
                
                console.log('üéØ About to call renderTaxonomyTree with:');
                console.log('  - name:', name);
                console.log('  - jsTreeNodes:', jsTreeNodes);
                console.log('  - taxonomyLevels:', taxonomyLevels);
            
                renderTaxonomyTree(name, jsTreeNodes, taxonomyLevels);
                
                // Enable the save button after successful import
                $('#saveButton').prop('disabled', false);
                markTreeDirty(); // Mark tree as modified
                
                // Count total nodes in the imported tree for the counter
                console.log('üîç Debugging counter issue:');
                console.log('  - jsTreeNodes:', jsTreeNodes);
                console.log('  - jsTreeNodes type:', typeof jsTreeNodes);
                console.log('  - jsTreeNodes length:', jsTreeNodes?.length);
                console.log('  - First node:', jsTreeNodes?.[0]);
                
                // Try counting from the original sheet data as a backup
                const sheetNodeCount = sheet.length;
                console.log('  - Sheet row count (alternative):', sheetNodeCount);
                
                const totalNodeCount = countNodesInTree(jsTreeNodes);
                console.log('  - countNodesInTree result:', totalNodeCount);
                
                // Use the higher count between the two methods
                const finalCount = Math.max(totalNodeCount, sheetNodeCount);
                console.log('  - Final count to use:', finalCount);
                
                nodesToCreate = finalCount;
                $("#nodesToCreate").html(finalCount);
                console.log(`üìä Total nodes to create: ${finalCount}`);
                console.log('  - nodesToCreate variable:', nodesToCreate);
                console.log('  - DOM element value:', $("#nodesToCreate").html());
                
                console.log('‚úÖ Save button enabled after import');
              };
              
              reader.onerror = function(e) {
                console.error('‚ùå File read error:', e);
              };
            
              console.log('üìñ Starting to read file...');
              reader.readAsArrayBuffer(file);
            });
            
            
            
            
            
            
                        
              
              
              $('#allTemplates').on('change', async function () {
                const taxonomyKey = this.value;
                $('#selectedTemplates').html("Selected Taxonomy: " + $('#allTemplates option:selected').text());
              
                const taxonomy = metadataTaxonomies.entries.find(t => t.key === taxonomyKey);
                const taxonomyJSON = await getTaxonomyByKey(namespace, taxonomyKey);
                const nodesJson = await getNodes(namespace, taxonomyKey);
              
                taxonomyLevels = taxonomyJSON.levels;
                originalEntries = nodesJson.entries.sort((a, b) => a.displayName.localeCompare(b.displayName));
              
                const nestedTree = buildTreeFromFlatList(originalEntries);
                const maxLevel = Math.max(...originalEntries.map(n => n.level));
                const jsTreeNodes = convertNestedToJsTree(nestedTree, maxLevel);
              
                $('#taxonomyKey').val(taxonomy.key);
                $('#taxonomyDisplayName').val(taxonomy.displayName);
              
                renderTaxonomyTree(taxonomy.displayName, jsTreeNodes, taxonomyLevels);
              });
              
              function renderTaxonomyTree(displayName, jsTreeNodes, taxonomyLevels) {
                console.log('üé® renderTaxonomyTree called with:');
                console.log('  - displayName:', displayName);
                console.log('  - jsTreeNodes:', jsTreeNodes);
                console.log('  - taxonomyLevels:', taxonomyLevels);
                
                if ($.jstree.reference('#tree')) {
                  console.log('üóëÔ∏è Destroying existing tree');
                  $('#tree').jstree('destroy').empty();
                }
              
                const treeData = [{
                  id: 'taxonomy_root',
                  text: displayName,
                  icon: 'jstree-folder',
                  state: { opened: true },
                  children: jsTreeNodes
                }];
                
                console.log('üå≤ Tree data to render:', treeData);
                console.log('üå≤ Root node children count:', treeData[0]?.children?.length || 0);
                console.log('üå≤ First child node:', treeData[0]?.children?.[0]);
              
                $('#tree').jstree({
                  core: {
                    check_callback: true,
                    data: treeData
                  },
                  plugins: ['contextmenu', 'dnd', 'unique'],
                  contextmenu: {
                    items: function (node) {
                      const tree = $('#tree').jstree(true);
                      const depth = tree.get_path(node).length;
                      const canAddChild = depth < taxonomyLevels.length + 1;
              
                      return {
                        ...(canAddChild && {
                          addChild: {
                            label: `Add ${taxonomyLevels[depth - 1]?.displayName || 'Item'}`,
                            action: function () {
                              const newId = `NEW_${Date.now()}`;
                              tree.create_node(node, {
                                id: newId,
                                text: `New ${taxonomyLevels[depth - 1]?.displayName}`,
                                icon: depth === taxonomyLevels.length ? 'jstree-file' : 'jstree-folder'
                              }, 'last');
                            }
                          }
                        }),
                        rename: {
                          label: 'Rename',
                          action: () => tree.edit(node)
                        },
                        delete: {
                          label: 'Delete',
                          action: () => tree.delete_node(node)
                        }
                      };
                    }
                  }
                });
                
                console.log('‚úÖ Tree rendered successfully');
              
                $('#tree').on('select_node.jstree', function (e, data) {
                  setTimeout(() => {
                    $('#tree').jstree(true).edit(data.node);
                  }, 100);
                });
                $('#tree').on('create_node.jstree rename_node.jstree delete_node.jstree move_node.jstree', function () {
                  markTreeDirty();
                });
                

              }
                  function markTreeDirty() {
      $('#saveButton').prop('disabled', false);
    }
    
    // Helper function to count total nodes in a tree structure
    function countNodesInTree(nodes) {
      console.log('üî¢ countNodesInTree called with:', nodes);
      console.log('  - nodes type:', typeof nodes);
      console.log('  - isArray:', Array.isArray(nodes));
      
      if (!Array.isArray(nodes)) {
        console.log('  - Not an array, returning 0');
        return 0;
      }
      
      let count = 0;
      console.log('  - Starting count, nodes length:', nodes.length);
      
      for (const node of nodes) {
        count++; // Count this node
        console.log(`  - Counted node ${count}:`, node);
        
        if (node.children && Array.isArray(node.children)) {
          console.log(`  - Node has ${node.children.length} children, recursing...`);
          const childCount = countNodesInTree(node.children);
          count += childCount;
          console.log(`  - Added ${childCount} children, total now: ${count}`);
        } else {
          console.log(`  - Node has no children or children is not an array`);
        }
      }
      
      console.log(`  - Final count for this level: ${count}`);
      return count;
    }
    



            try {
                //Create a Box client using the token
                client = new BoxClient({auth: new BoxDeveloperTokenAuth({token: accessToken }),
                });
               eid = await getEid(client); 

            }
            catch (e) {
                console.error(e);
            }
          
            metadataTaxonomies = await getTaxonomiesByNamespace(namespace);
            metadataTaxonomies.entries.forEach(function(temp) {
                
            $('#allTemplates').append($('<option>', {
                value: temp.key,
                text: temp.displayName + ' (' + temp.key + ')',
            }));
                
            })
            
            // Enable "Create New" button - users should be able to create new taxonomies
            $('button[data-bs-target="#taxonomyModal"]').prop('disabled', false);
            
            // Reset modal state when it's closed
            $('#taxonomyModal').on('hidden.bs.modal', function () {
              // Reset AI state
              aiGeneratedData = null;
              $('#aiPreviewSection').hide();
              $('#approveAIGenerated').hide();
              $('#regenerateAI').hide();
              $('#manualLevelSection').show();
              $('#aiPrompt').val('');
              $('#aiError').hide();
              $('#aiLoadingSpinner').addClass('d-none');
              $('#aiButtonText').text('Let AI create the taxonomy values');
              $('#aiSuggest').prop('disabled', false);
              
              // Destroy preview tree if it exists
              if ($.jstree.reference('#aiPreviewTree')) {
                $('#aiPreviewTree').jstree('destroy').empty();
              }
            });
                
            $('#saveButton').on('click', async function () {
              $("#loader").show();
              // Disable save button during operation, but keep "Create New" enabled
              $('#saveButton').prop("disabled", true);
            
              const treeData = $('#tree').jstree(true).get_json('#', { flat: false });
              const flattened = [];
            
              function flatten(nodes, level = 1, parentId = null) {
                for (const node of nodes) {
                  if (!node || typeof node !== 'object') continue;
              
                  if (node.id === 'taxonomy_root') {
                    flatten(node.children || [], level, null);
                    continue;
                  }
              
                  const levelName = taxonomyLevels[level - 1]?.displayName;
                  const displayName = node.displayName || node[levelName] || node.text || "Unnamed";
              
                  const entry = {
                    id: node.id,
                    displayName,
                    level,
                    parent_id: parentId
                  };
              
                  flattened.push(entry);
                  console.log("üì¶ Flattened:", entry);
              
                  if (node.children?.length) {
                    flatten(node.children, level + 1, node.id);
                  }
                }
              }
              
              
              flatten(treeData);
            
              const taxonomyKey = $('#taxonomyKey').val().trim();
              const displayName = $('#taxonomyDisplayName').val().trim();
              taxonomyId = taxonomyKey;
            
              const currentEntries = flattened;
            
              if (originalEntries.length === 0) {
                const rootNode = treeData.find(n => n.id === 'taxonomy_root');
                const nodes = rootNode ? rootNode.children || [] : treeData;
              
                const newTree = {
                  key: taxonomyKey,
                  displayName,
                  nodes // ‚úÖ pass actual nested tree
                };
              
                await createNewTaxonomyTree(newTree, taxonomyLevels, namespace, taxonomyId);
                await refreshTaxonomyTree(namespace, taxonomyKey);
              
                $("#loader").hide();
                $('#saveButton').prop("disabled", false);
                return;
              
              }
            
              // update existing
              const originalMap = Object.fromEntries(originalEntries.map(n => [n.id, n]));
              const currentMap = Object.fromEntries(currentEntries.map(n => [n.id, n]));
            
              const toCreate = currentEntries.filter(n => n.id.startsWith('NEW_'));
              const toDelete = originalEntries.filter(n => !currentMap[n.id]);
              currentEntries.forEach(n => {
                if (!n.id.startsWith('NEW_') && originalMap[n.id]) {
                  const orig = originalMap[n.id];
                  if (areNodesDifferent(orig, n)) {
                    console.log(`üß™ Diff:`, { id: n.id, original: orig, current: n });
                  }
                }
              });
              const toUpdate = currentEntries.filter(n =>
                !n.id.startsWith('NEW_') &&
                originalMap[n.id] &&
                areNodesDifferent(originalMap[n.id], n)
              );
            
              console.group("üîÑ Taxonomy Change Detection");
              console.log("üÜï To Create", toCreate);
              $("#nodesToCreate").html(toCreate.length);
              console.log("üóëÔ∏è To Delete", toDelete);
              console.log("‚úèÔ∏è To Update", toUpdate);
              console.groupEnd();
            
              createNodes(toCreate);
              deleteNodes(toDelete);
              updateNodes(toUpdate);
              await refreshTaxonomyTree(namespace, taxonomyId);

              $("#loader").hide();
              $('#saveButton').prop("disabled", false);
            });
            
            let createdTaxonomyLevels = [];
            let aiGeneratedData = null; // Store AI-generated taxonomy data

                $('#levelCount').on('input', function () {
                const count = parseInt($(this).val());
                const $container = $('#levelInputs');
                $container.empty();

                for (let i = 1; i <= count; i++) {
                    $container.append(`
                    <div class="mb-2">
                        <label class="form-label">Level ${i} Name</label>
                        <input type="text" class="form-control level-name" data-level="${i}" placeholder="e.g., Country" />
                    </div>
                    `);
                }
                });
                
                // AI Generation Handler
                $('#aiSuggest').on('click', async function () {
                  const prompt = $('#aiPrompt').val().trim();
                  
                  if (!prompt) {
                    alert('Please enter a prompt describing the taxonomy you want to generate.');
                    return;
                  }
                  
                  // Show loading state
                  $('#aiLoadingSpinner').removeClass('d-none');
                  $('#aiButtonText').text('Generating...');
                  $('#aiSuggest').prop('disabled', true);
                  $('#aiError').hide();
                  
                  try {
                    // Call AI generation
                    const result = await generateTaxonomyWithAI(prompt);
                    aiGeneratedData = result;
                    
                    // Populate key and displayName fields from AI response
                    if (result.key) {
                      $('#taxonomyKey').val(result.key);
                    }
                    if (result.displayName) {
                      $('#taxonomyDisplayName').val(result.displayName);
                    }
                    
                    // Ensure all nodes have IDs for jstree
                    let nodeIdCounter = 1;
                    function assignIds(node) {
                      if (!node.id) {
                        node.id = `AI_NEW_${nodeIdCounter++}`;
                      }
                      if (node.children && Array.isArray(node.children)) {
                        node.children.forEach(assignIds);
                      }
                    }
                    result.nodes.forEach(assignIds);
                    
                    // Convert to jstree format
                    const maxLevel = Math.max(...result.levels.map((l, i) => i + 1));
                    const jsTreeNodes = convertNestedToJsTree(result.nodes, maxLevel);
                    
                    // Display preview
                    if ($.jstree.reference('#aiPreviewTree')) {
                      $('#aiPreviewTree').jstree('destroy').empty();
                    }
                    
                    const treeData = [{
                      id: 'ai_preview_root',
                      text: result.displayName || 'AI Generated Taxonomy',
                      icon: 'jstree-folder',
                      state: { opened: true },
                      children: jsTreeNodes
                    }];
                    
                    $('#aiPreviewTree').jstree({
                      core: {
                        check_callback: true,
                        data: treeData
                      },
                      plugins: ['contextmenu', 'dnd', 'unique']
                    });
                    
                    // Show preview section
                    $('#aiPreviewSection').show();
                    $('#approveAIGenerated').show();
                    $('#regenerateAI').show();
                    $('#manualLevelSection').hide();
                    
                    // Hide loading state
                    $('#aiLoadingSpinner').addClass('d-none');
                    $('#aiButtonText').text('Let AI create the taxonomy values');
                    $('#aiSuggest').prop('disabled', false);
                    
                  } catch (error) {
                    console.error('AI generation error:', error);
                    $('#aiError').text('Error: ' + error.message).show();
                    $('#aiLoadingSpinner').addClass('d-none');
                    $('#aiButtonText').text('Let AI create the taxonomy values');
                    $('#aiSuggest').prop('disabled', false);
                  }
                });
                
                // Regenerate Handler
                $('#regenerateAI').on('click', function () {
                  $('#aiSuggest').click();
                });
                
                // Approve AI Generated Taxonomy
                $('#approveAIGenerated').on('click', function () {
                  if (!aiGeneratedData) {
                    alert('No AI-generated data to approve.');
                    return;
                  }
                  
                  // Set taxonomy levels
                  taxonomyLevels = aiGeneratedData.levels.map((level, index) => ({
                    displayName: level.displayName,
                    description: level.description || level.displayName,
                    level: index + 1,
                    type: "metadata_taxonomy_level"
                  }));
                  
                  // Key and displayName should already be populated from AI generation
                  // But ensure they're set if somehow missing
                  if (!$('#taxonomyKey').val().trim()) {
                    $('#taxonomyKey').val(aiGeneratedData.key || 'ai_generated_taxonomy');
                  }
                  
                  if (!$('#taxonomyDisplayName').val().trim()) {
                    $('#taxonomyDisplayName').val(aiGeneratedData.displayName || 'AI Generated Taxonomy');
                  }
                  
                  // Convert AI node IDs from "AI_NEW_X" to "NEW_X" format for save handler
                  function convertNodeIds(node) {
                    if (node.id && node.id.startsWith('AI_NEW_')) {
                      node.id = node.id.replace('AI_NEW_', 'NEW_');
                    }
                    if (node.children && Array.isArray(node.children)) {
                      node.children.forEach(convertNodeIds);
                    }
                  }
                  aiGeneratedData.nodes.forEach(convertNodeIds);
                  
                  // Convert AI nodes to format expected by renderTaxonomyTree
                  const maxLevel = Math.max(...aiGeneratedData.levels.map((l, i) => i + 1));
                  const jsTreeNodes = convertNestedToJsTree(aiGeneratedData.nodes, maxLevel);
                  
                  // Reset original entries since this is a new taxonomy
                  originalEntries = [];
                  
                  // Render the tree
                  const displayName = $('#taxonomyDisplayName').val().trim() || 'AI Generated Taxonomy';
                  renderTaxonomyTree(displayName, jsTreeNodes, taxonomyLevels);
                  
                  // Set taxonomyId for save operation
                  taxonomyId = $('#taxonomyKey').val().trim();
                  
                  // Enable save button
                  $('#saveButton').prop('disabled', false);
                  
                  // Close modal
                  $('#taxonomyModal').modal('hide');
                  
                  // Reset AI state
                  aiGeneratedData = null;
                  $('#aiPreviewSection').hide();
                  $('#approveAIGenerated').hide();
                  $('#regenerateAI').hide();
                  $('#manualLevelSection').show();
                  $('#aiPrompt').val('');
                });

                $('#createTaxonomy').on('click', function () {
                    createdTaxonomyLevels = [];
                  
                    $('.level-name').each(function (i) {
                      const name = $(this).val().trim();
                      if (name) {
                        createdTaxonomyLevels.push({
                          displayName: name,
                          level: i + 1,
                          type: "metadata_taxonomy_level"
                        });
                      }
                    });
                  
                    const taxonomyKey = $('#taxonomyKey').val().trim();
                    const taxonomyDisplayName = $('#taxonomyDisplayName').val().trim();
                  
                    if (!taxonomyKey || !taxonomyDisplayName) {
                      alert('Please enter both Key and Display Name');
                      return;
                    }
                  
                    if (createdTaxonomyLevels.length === 0) {
                      alert('Please add at least one level');
                      return;
                    }
                  
                    // Set taxonomy levels from created levels
                    taxonomyLevels = createdTaxonomyLevels.map(level => ({
                      displayName: level.displayName,
                      level: level.level,
                      type: level.type
                    }));
                  
                    // Set form fields
                    $('#taxonomyKey').val(taxonomyKey);
                    $('#taxonomyDisplayName').val(taxonomyDisplayName);
                  
                    // Reset original entries since this is a new taxonomy
                    originalEntries = [];
                  
                    // Initialize empty jstree
                    const emptyTree = [];
                    renderTaxonomyTree(taxonomyDisplayName, emptyTree, taxonomyLevels);
                  
                    // Set taxonomyId for save operation
                    taxonomyId = taxonomyKey;
                  
                    // Enable save button
                    $('#saveButton').prop('disabled', false);
                  
                    $('#taxonomyModal').modal('hide');
                  });
                                    
                  
                  async function refreshTaxonomyTree(namespace, taxonomyId) {
                    console.log("Refreshing taxonomy tree...", taxonomyId);
                    
                    try {
                      const taxonomy = metadataTaxonomies.entries.find(t => t.key === taxonomyId);
                      console.log("Found taxonomy:", taxonomy);
                      
                      if (!taxonomy) {
                        console.warn(`‚ö†Ô∏è Taxonomy not found in metadataTaxonomies for key: ${taxonomyId}`);
                        console.log("Available taxonomies:", metadataTaxonomies.entries.map(t => ({ key: t.key, displayName: t.displayName })));
                        return; // Exit early if taxonomy not found
                      }
                      
                      const taxonomyJSON = await getTaxonomyByKey(namespace, taxonomyId);
                      const nodesJson = await getNodes(namespace, taxonomyId);
                    
                      taxonomyLevels = taxonomyJSON.levels;
                      originalEntries = nodesJson.entries.sort((a, b) => a.displayName.localeCompare(b.displayName));
                      const tree = buildTreeFromFlatList(originalEntries);
                      const maxLevel = Math.max(...originalEntries.map(n => n.level));
                      const jsTreeNodes = convertNestedToJsTree(tree, maxLevel);
                    
                      //$('#taxonomyKey').val(taxonomy.taxonomyKey);
                      //$('#taxonomyDisplayName').val(taxonomy.displayName);
                      console.log("Rendering taxonomy tree with:", {
                        displayName: taxonomy.displayName,
                        nodeCount: jsTreeNodes.length,
                        levels: taxonomyLevels
                      });
                      
                      renderTaxonomyTree(taxonomy.displayName, jsTreeNodes, taxonomyLevels);
                      // Only reset counters if we're not in import mode (i.e., if taxonomyId already exists)
                      if (originalEntries.length === 0) {
                        setNodesToCreate();
                      }
                      
                    } catch (error) {
                      console.error("‚ùå Error in refreshTaxonomyTree:", error);
                      console.error("Error details:", {
                        namespace,
                        taxonomyId,
                        metadataTaxonomies: metadataTaxonomies?.entries?.length || 0
                      });
                    }
                  }

        })
        
        
        function setNodesToCreate() {
            nodesToCreate = 0;
            nodesCreated = 0;
            $("#nodesToCreate").html(nodesToCreate);
            $("#nodesCreated").html(nodesCreated);  
        }   
        function incrementNodesCreated() {
            nodesCreated++;
            $("#nodesCreated").html(nodesCreated);  
        }
              
           
            
        
        
        async function getEid() {
            let user = await  client.users.getUserMe({"fields":["id,name,enterprise"]});
            eid = user.enterprise.id;
            namespace = "enterprise_" + eid;
        }
        let metadataTemplateMap = [];
        let totalSize=0;
        
        function enhanceSchema(schema) {
          function recurse(sch, isRoot = false) {
            if (sch.type === 'object' && sch.properties) {
              if (!isRoot) sch.title = '';
              Object.values(sch.properties).forEach(recurse);
            } else if (sch.type === 'array') {
              sch.title = '';
              if (sch.items) {
                recurse(sch.items);
                sch.items.title = '';
              }
            }
          }
          recurse(schema, true);
          return schema;
        }
        
        
       
    function removeLastLevelHeaderRow(levels) {
      console.log(levels);
      const lastLevelName = levels[levels.length - 1].displayName;
      document.querySelectorAll('table thead').forEach(thead => {
        const tr = thead.querySelector('tr');
        if (!tr) return;
        const ths = [...tr.querySelectorAll('th')];
        const match = ths.some(th => th.textContent.trim() === lastLevelName);
        if (match) thead.remove();
      });
    }

    function hideWrapperCollapseAndControls() {
      document.querySelectorAll('.je-object__title').forEach(titleEl => {
        const spans = titleEl.querySelectorAll('span');
        if (spans.length < 2) return;
        const label = spans[1].textContent.trim();
        if (/^[A-Za-z]+ \d+$/.test(label)) {
          titleEl.style.setProperty('display', 'none', 'important');
          const controls = titleEl.parentElement?.querySelector('.je-object__controls');
          if (controls) controls.style.setProperty('display', 'none', 'important');
        }
      });
    }
     
    </script>
</head>
<body>   <header class="header">
    <!-- Left side links -->
    <div class="left">
        <a href="index.html">
            <i class="bi bi-house-door"></i> Home
        </a>
        <a href="index_oauth.html">
                        <i class="bi bi-box-arrow-in-right"></i> Login
        </a>
    </div>

    <!-- Center links -->
    <div class="center">
        <a href="export.html"><i class="bi bi-arrow-up-circle"></i> Export</a>
        <a href="import.html" ><i class="bi bi-arrow-down-circle"></i> Import</a>
        <a href="apply.html"><i class="bi bi-check-circle"></i> Apply</a>
        <a href="delete.html" class="text-warning"><i class="bi bi-exclamation-triangle-fill text-warning"></i> Delete Template</a>
        <a href="docgen.html" ><i class="bi bi-tools"></i> Generate documents</a>
        <a href="taxonomies.html" class="active"><i class="bi bi-share"></i>Taxonomies</a>
        <a href="agents.html"><i class="bi bi-robot"></i>AI Agents</a>


    </div>

    <!-- Right side could have more links or branding if needed -->
    <div class="right">
        <!-- Placeholder for potential right-aligned content -->
    </div>
</header>
    <div class="container mt-3 mb-2">
        <a href="taxonomies.html" class="btn btn-link p-0 ps-1"><i class="bi bi-share"></i> Share taxonomies</a>
    </div>
    <div class="container mt-5">
        <!-- Header -->
        <header class="text-center mb-2">
            <h3>Create and edit taxonomies (BETA)</h3>
        </header>
        <div class="row">
            <div class="col-md-12">
                <div class="section la">Instructions: <ul>
                    <li>This page will allow you to create and edit taxnomies</li>
                    <li>Select a taxonomy, click 'Create new' or Import an xlsx file (<a href="https://peter-demo.box.com/s/yxzlk3svu58v1wajkbxde7m44pvrwhfg" target="_blank">sample</a>)</li>
                    <li>Use the editor to edit - you can add new nodes within each level, but not add new levels currently</li>
                    <li>Coming soon: Associate with metadata templates, see metadata templates were taxonomy is used</li>
                    </ul>
                
                 </div>
            </div>
        </div>
        <!-- Row with two sections -->
        <div class="row">
            <div class="col-md-4">
                <h4>Select Metadata Taxonomy</h4>
                <div class="transfer-container section d-flex flex-column" style="height:400px !important">
                    <!-- Select Box 1 -->
                    <select id="allTemplates" class="form-select" multiple style="height:350px;" size="35">
                        
                    </select>
                    <div class="section" style="width: 100%">
                        <div class="">
                            <ul class="list-group">
                               
                                <li class="list-group-item">
                                    Taxonomy Nodes to create
                                    <span class="badge rounded-pill bg-primary counter" id="nodesToCreate">0</span>
                                </li>
    
                                <li class="list-group-item">
                                    Taxonomy nodes created
                                    <span class="badge rounded-pill bg-primary counter" id="nodesCreated">0</span>
                                </li>
                                
                            </ul>
    
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-8">
                <h4>Edit</h4>

                <div class="section">
                    <h4 id="selectedTemplates"></h4>
                    <div id="sec3content">
                        <div class="button-section">
                            <button class="btn btn-primary action" id="saveButton" disabled>Save</button>
                            <button class="btn btn-primary action" data-bs-toggle="modal" data-bs-target="#taxonomyModal" disabled>Create New</button>
                            <button class="btn btn-secondary action" id="import" >Import</button>
                            <input type="file" id="fileInput" accept=".xlsx" style="display:none;">
                            <img src="ajax-loader.gif" id="loader" height="32" class="loading" style="display:none;"/>
                        </div>
                       
                    </div>

                   
                 
                </div>

                <div id="tree" style="height:500px;" class="tree"></div>
                <div id="editor2">
        
            </div>
            
                </div>
        </div>
        <div class="row">
            <div class="col-md-4">

               
            </div>

        </div>
       
    </div>
<!-- Trigger -->

<!-- Modal -->
<div class="modal fade" id="taxonomyModal" tabindex="-1" aria-labelledby="taxonomyModalLabel" aria-hidden="true" style="display:none;">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="taxonomyModalLabel">Create New Taxonomy</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
            <input type="text" id="taxonomyKey" placeholder="Key" />
            <input type="text" id="taxonomyDisplayName" placeholder="Display Name" /><br/>
        </div>
        
        <!-- AI Prompt Section -->
        <div class="mb-3">
          <label for="aiPrompt" class="form-label">AI Prompt (Optional)</label>
          <textarea class="form-control" id="aiPrompt" rows="3" placeholder="e.g., generate a two level taxonomy for VW car makes and models"></textarea>
          <button id="aiSuggest" class="btn btn-outline-secondary w-100 mt-2">
            <span class="spinner-border spinner-border-sm d-none" id="aiLoadingSpinner" role="status" aria-hidden="true"></span>
            <span id="aiButtonText">Let AI create the taxonomy values</span>
          </button>
        </div>
        
        <!-- AI Preview Section (hidden by default) -->
        <div id="aiPreviewSection" class="mb-3" style="display:none;">
          <h6>AI Generated Preview</h6>
          <div id="aiPreviewTree" style="height:300px; overflow-y:auto; border:1px solid #dee2e6; padding:10px; border-radius:4px;"></div>
          <div id="aiError" class="alert alert-danger mt-2" style="display:none;"></div>
        </div>
        
        <!-- Manual Level Input Section -->
        <div id="manualLevelSection">
          <label for="levelCount" class="form-label">Number of Levels</label>
          <input type="number" class="form-control" id="levelCount" min="0" max="5" value="0">
          <div id="levelInputs"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button id="approveAIGenerated" type="button" class="btn btn-success" style="display:none;">Approve</button>
        <button id="regenerateAI" type="button" class="btn btn-outline-primary" style="display:none;">Regenerate</button>
        <button id="createTaxonomy" type="button" class="btn btn-primary">Create</button>
      </div>
    </div>
  </div>
</div>

    <!-- Bootstrap JS and dependencies -->
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Font Awesome for connection button icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Connection Status HTML -->
    <div id="connectionStatusContainer"></div>
    
    <!-- Connection Status JavaScript -->
    <script src="connection-status.js"></script>
    <script>
        // Load connection status HTML
        $(document).ready(function() {
            $('#connectionStatusContainer').load('connection-status.html', function() {
                console.log("Connection status HTML loaded, updating status...");
                // Update connection status after HTML is loaded
                if (typeof updateConnectionStatus === 'function') {
                    setTimeout(updateConnectionStatus, 100);
                }
            });
        });
    </script>
</body>
</html>